# SPI (Serial Peripheral Interface) Protocol

```
   ┌─────────────────────────────────────────────┐
   │          SPI COMMUNICATION MODEL             │
   │                                             │
   │    ┌─────────────┐                         │
   │    │    MASTER    │                         │
   │    └─┬─┬─┬─┬─┘                         │
   │      │ │ │ │                           │
   │  SCLK │ │ │ │                           │
   │  ────── │ │ │                           │
   │  MOSI │ │ │ │                           │
   │  ─────── │ │                           │
   │  MISO │ │ │ │                           │
   │  ──────── │                           │
   │  CS1  │ │ │                            │
   │  ─────────                            │
   │  CS2  │ │                             │
   │  ──────────                            │
   │  CS3  │                              │
   │  ──────────                            │
   │      │ │ │ │                           │
   │      ↓ ↓ ↓ ↓                           │
   │    ┌──┬─┘ ┌──┬─┘ ┌──┬─┘             │
   │    │SLAVE│ │SLAVE│ │SLAVE│             │
   │    │  1  │ │  2  │ │  3  │             │
   │    └────┘ └────┘ └────┘             │
   │                                             │
   └─────────────────────────────────────────────┘
```

In the ecosystem of embedded communications, the Serial Peripheral Interface (SPI) stands as a high-performance contender, offering remarkable simplicity paired with impressive speed capabilities. Developed by Motorola in the mid-1980s, SPI has evolved into one of the most widely adopted protocols for short-distance communication in embedded systems, particularly where speed-critical applications demand efficient data transfer.

Unlike the address-based sharing approach of I²C, SPI takes a direct, dedicated connection approach. It creates point-to-point links between a controlling master device and its selected peripheral slaves, establishing a straightforward communication channel that sacrifices pin efficiency for performance and simplicity. This architecture makes SPI particularly valuable for applications requiring high-throughput data transfer, such as interfacing with sensors that produce large data volumes, connecting to high-resolution displays, or accessing flash memory where read and write speed directly impacts system performance.

For hardware hackers, SPI interfaces represent prime targets for exploration. They frequently connect to some of the most valuable components in modern electronics—firmware storage chips, encryption modules, and configuration memories. The protocol's widespread adoption, combined with its lack of built-in security features, creates numerous opportunities for security research and device analysis. Understanding SPI fundamentals provides a foundation for advanced hardware hacking techniques, from passive analysis to active manipulation of target systems.

## SPI Fundamentals

### Basics of SPI

The Serial Peripheral Interface distinguishes itself from other communication protocols through several defining characteristics that shape both its applications and security profile.

**Synchronous communication** forms the foundation of SPI operation. Unlike asynchronous protocols like UART that require precise timing agreement, SPI uses an explicit clock signal (SCLK) generated by the master to coordinate all data transfers. This clock synchronization offers several advantages:
- Eliminates the need for timing calibration between devices
- Allows for flexible communication speeds that can be adjusted on-the-fly
- Supports higher data rates than many asynchronous protocols
- Provides greater tolerance for timing variations between components

At each clock pulse, data bits transfer between master and slave, creating a structured and reliable communication system with little overhead.

**Full-duplex capability** sets SPI apart from many other serial protocols by enabling simultaneous bidirectional data transfer. With separate data lines for transmission (MOSI - Master Out Slave In) and reception (MISO - Master In Slave Out), the master and selected slave can send data to each other at the same time. This simultaneous communication doubles the effective throughput compared to half-duplex protocols, making SPI particularly efficient for applications requiring continuous data exchange, such as streaming sensor readings while sending configuration commands.

**The four-wire interface** represents the standard SPI implementation, though variations exist:

1. SCLK (Serial Clock) - The master-generated timing reference
2. MOSI (Master Out Slave In) - Data from master to slave 
3. MISO (Master In Slave Out) - Data from slave to master
4. CS/SS (Chip Select/Slave Select) - Selection signal for specific slave devices

Additional signal lines may appear in some implementations, such as write protection (WP) or hold (HOLD), particularly with memory devices. These supplementary lines provide additional control options but aren't part of the core SPI specification.

**The master-slave architecture** establishes a clear hierarchy in SPI systems. The master device (typically a microcontroller or processor) controls all aspects of communication:
- Generating the clock signal that times all transfers
- Selecting which slave device to communicate with
- Initiating all data transfers
- Determining the communication speed

Slave devices remain passive participants, responding only when selected by the master via their respective CS lines. This centralized control simplifies the protocol by eliminating the need for bus arbitration or collision detection mechanisms found in multi-master protocols, but it also concentrates security control at the master device.

```
   ┌─────────────────────────────────────────────┐
   │           SPI SIGNAL TRANSFER                │
   │                                             │
   │  CS   ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄    │
   │       ██                              ██    │
   │  SCLK ██████_██████_██████_██████_██████    │
   │                                             │
   │  MOSI ████████__██__████████__██__██████    │
   │            bit7  bit6  bit5  bit4  bit3      │
   │                                             │
   │  MISO ██__████████__██__████████__██__    │
   │            bit7  bit6  bit5  bit4  bit3      │
   │                                             │
   └─────────────────────────────────────────────┘
```

**The absence of an addressing scheme** differentiates SPI from protocols like I²C. Rather than sending address information over the data lines, SPI uses dedicated Chip Select (CS) lines for each slave device. When the master wishes to communicate with a specific slave, it activates only that slave's CS line (typically by driving it low) while keeping all other CS lines inactive. This direct selection approach:
- Eliminates addressing overhead in the data stream
- Allows for simpler slave implementation
- Supports any number of identical devices without address conflicts
- Creates a potential scaling issue as each slave requires a dedicated CS line

The direct selection method makes SPI particularly efficient for small numbers of peripherals but less practical for systems with many devices due to the increasing pin count requirements.

**Superior speed capabilities** make SPI the protocol of choice for performance-critical applications. Without the overhead of addressing or acknowledgment bits, and with clock rates frequently running from 10 MHz to 100+ MHz, SPI can achieve data transfer rates orders of magnitude faster than I²C or UART. This high-speed capability makes SPI ideal for:
- Flash memory access where read/write speed is critical
- Display interfaces requiring high refresh rates
- Data acquisition from high-resolution sensors
- Real-time control applications with strict timing requirements

For hardware hackers, this speed characteristic is significant since it may require more sophisticated equipment to properly analyze SPI signals at their maximum rates.

### Signal Lines

The four signal lines that comprise standard SPI each serve specific functions in creating a robust communication channel. Understanding their roles and characteristics is essential for both analyzing and manipulating SPI interfaces.

**SCLK (Serial Clock)** provides the timing foundation for all SPI communications. Generated exclusively by the master device, this signal coordinates when data bits are placed on the data lines and when they should be sampled by the receiving device. Key characteristics include:

- **Programmable frequency**: The master can adjust clock speed to accommodate different slave capabilities
- **Idle state**: Can be configured to rest at either high or low (determined by CPOL parameter)
- **Active edges**: Either rising or falling edges can trigger data sampling (determined by CPHA parameter)
- **Continuous operation**: During a transfer, the clock runs continuously until all data is exchanged

From a security perspective, the clock line can be monitored to determine when sensitive data might be transferred, potentially enabling timing-based attacks.

**MOSI (Master Out Slave In)** carries data from the master to the selected slave(s). This unidirectional line has several important characteristics:

- **Bit ordering**: Data is typically transmitted most significant bit (MSB) first, though some implementations use least significant bit (LSB) first
- **Data placement**: The master places new bits on this line in coordination with the clock signal
- **Shared connection**: All slaves receive the same MOSI signal, but only the selected device (with active CS) processes it
- **Idle state**: When not transmitting, this line may float or be driven to a specific level depending on implementation

From a hardware hacking perspective, the MOSI line carries command sequences, addresses, and write data—all potentially valuable information for understanding device operation or identifying security weaknesses.

**MISO (Master In Slave Out)** serves as the return path, carrying data from the selected slave back to the master. Its characteristics mirror MOSI but in the opposite direction:

- **Single active driver**: Only the currently selected slave should drive this line
- **High-impedance state**: Unselected slaves must tri-state their MISO connections to avoid conflicts
- **Data timing**: The slave places data on this line synchronized with the clock signal
- **Shared connection**: Despite coming from different slaves, all MISO outputs connect to a single master input

For hardware security analysis, the MISO line carries response data that may include sensitive information like configuration data, memory contents, or status information revealing the internal state of the target device.

**CS/SS (Chip Select/Slave Select)** implements the direct addressing mechanism of SPI. These dedicated selection lines have several distinctive properties:

- **Active-low operation**: Typically, a low voltage (0) selects a slave while high (1) deselects it
- **One per slave**: Each slave device requires its own dedicated CS line from the master
- **Multiple selects**: Some implementations allow selecting multiple slaves simultaneously for broadcast operations
- **Framing function**: The CS transition from inactive to active signals the start of a transaction, while the return to inactive marks its completion

The CS lines effectively serve as an "enable" signal, determining which slave device is currently allowed to participate in communication. This direct selection method is both a strength (no addressing overhead) and a limitation (requires more pins) of the SPI protocol.

### SPI Modes

<table>
  <tr>
    <th>Mode</th>
    <th>CPOL<br>(Clock Polarity)</th>
    <th>CPHA<br>(Clock Phase)</th>
    <th>Clock Idle State</th>
    <th>Data Sampled On</th>
    <th>Common Devices</th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>Low</td>
    <td>Rising Edge</td>
    <td>Most Microcontrollers, Many Flash Memory Chips</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>Low</td>
    <td>Falling Edge</td>
    <td>TI Digital Signal Processors, Some Sensors</td>
  </tr>
  <tr>
    <td>2</td>
    <td>1</td>
    <td>0</td>
    <td>High</td>
    <td>Falling Edge</td>
    <td>Motorola Processors (Older), Some Display Controllers</td>
  </tr>
  <tr>
    <td>3</td>
    <td>1</td>
    <td>1</td>
    <td>High</td>
    <td>Rising Edge</td>
    <td>AD Converters, Some Memory Devices</td>
  </tr>
</table>

One of SPI's distinctive characteristics is its configurability through four different operating modes, determined by two key parameters: clock polarity (CPOL) and clock phase (CPHA). This flexibility allows SPI to adapt to various slave device requirements but also introduces a layer of complexity for both developers and hardware hackers. Understanding these modes is crucial for successful communication and analysis.

**Clock Polarity (CPOL)** determines the idle state of the clock line (SCLK) when no data is being transferred:
- When CPOL=0, the clock idles at a low voltage level (0)
- When CPOL=1, the clock idles at a high voltage level (1)

This parameter effectively defines the "resting state" of the clock signal and forms the baseline from which active clock cycles are measured. The choice of polarity often depends on the slave device specifications or system-wide power considerations.

**Clock Phase (CPHA)** determines the timing relationship between clock edges and data sampling:
- When CPHA=0, data is sampled on the "first" clock edge (transition from idle)
- When CPHA=1, data is sampled on the "second" clock edge (transition back toward idle)

This parameter defines when the receiving device should consider the data on the line to be valid and stable. The selection of clock phase impacts the timing margins available for data setup and can affect reliability in high-speed applications.

**The resulting four modes** create distinct timing patterns that must be correctly matched between master and slave devices:

- **Mode 0 (CPOL=0, CPHA=0)**: Clock idles low, data is sampled on the rising edge (clock transition from low to high), and data changes on the falling edge. This is the most commonly used mode and often serves as the default for many SPI implementations.

- **Mode 1 (CPOL=0, CPHA=1)**: Clock idles low, data is sampled on the falling edge (clock transition from high to low), and data changes on the rising edge. This mode provides additional setup time for data bits when operating at higher frequencies.

- **Mode 2 (CPOL=1, CPHA=0)**: Clock idles high, data is sampled on the falling edge (clock transition from high to low), and data changes on the rising edge. This mode is less common but required by some specialized peripherals.

- **Mode 3 (CPOL=1, CPHA=1)**: Clock idles high, data is sampled on the rising edge (clock transition from low to high), and data changes on the falling edge. This mode is particularly common in certain analog-to-digital converters and some memory devices.

For hardware hackers, correctly identifying the SPI mode is essential for meaningful analysis. When monitoring SPI communications with a logic analyzer, selecting the wrong mode interpretation can result in completely misinterpreted data. Many SPI analysis tools provide automated mode detection by examining the relationship between CS activation, clock behavior, and data transitions.

During security assessments, it's sometimes necessary to attempt communication using different modes sequentially until correct operation is achieved. This trial-and-error approach is particularly relevant when working with undocumented devices or when manufacturer specifications are unavailable.

## Identifying SPI Interfaces

```
   ┌─────────────────────────────────────────────┐
   │        COMMON SPI INTERFACE INDICATORS       │
   │                                             │
   │   PCB Labels:            Flash Packages:     │
   │                                             │
   │    MOSI ○               ┌────────┐     │
   │    MISO ○               │ W25Q128  │     │
   │    SCLK ○               │ SOIC-8   │     │
   │    CS   ○               └────────┘     │
   │                                             │
   │   Test Points:          Pin Headers:         │
   │                                             │
   │    ○──○──○──○         ●──●──●──●        │
   │    TP1 TP2 TP3 TP4      1  2  3  4        │
   │                        S  M  M  G        │
   │                        C  O  I  N        │
   │                        L  S  S  D        │
   │                        K  I  O           │
   │                                             │
   └─────────────────────────────────────────────┘
```

Locating SPI interfaces on target hardware represents the critical first step in any SPI-based hardware hacking endeavor. Despite the protocol's ubiquity in embedded systems, SPI connections may be more or less obvious depending on design choices and whether the manufacturer intended to facilitate or obscure access. Successful identification combines visual inspection with electrical analysis techniques.

### Visual Identification

Physical examination of the printed circuit board often reveals telltale signs of SPI interfaces, particularly on development boards or consumer electronics where cost constraints limit efforts to hide these connections.

**Labeled pins and headers** provide the most direct identification method. Many devices explicitly mark SPI connections on the PCB silkscreen with standard labels including "MOSI," "MISO," "SCLK," and "CS" or "SS." Alternative abbreviations include "SDI/SDO" (Serial Data In/Out), "SCK" (Serial Clock), or simply "SPI" to indicate a grouped interface. Education and development boards typically feature the clearest labeling, while consumer products might use less obvious designations or reference designators (e.g., TP1, TP2). 

When examining boards, look for these labels near:
- Pin headers (both populated and unpopulated)
- Test points or pads arranged in groups of 4+ pins
- Primary processors or microcontrollers
- Edge connectors or expansion interfaces

**Flash memory packages** represent one of the most common and valuable SPI-connected components. Several characteristics help identify these devices:

- **Package types**: Common SPI flash chips use SOIC-8, SOIC-16, WSON-8, or DFN-8 packages
- **Manufacturer markings**: Look for logos or codes from Winbond (W25xxx), Macronix (MX25xxx), Spansion/Cypress, Micron, or other flash memory manufacturers
- **Placement**: These chips are typically positioned near the main processor, often on the same side of the board
- **Silk-screen identifiers**: Labels like "U3," "Flash," or "Boot" may indicate SPI flash memory

Many consumer electronics, networking equipment, and IoT devices store their firmware and configuration in these external SPI flash chips, making them prime targets for hardware security research.

**Multiple chip select lines** often indicate SPI architecture, as each slave device requires its own dedicated select signal. Look for:

- Multiple traces branching from a microcontroller to different components
- Several pins labeled CS, SS, or CE (Chip Enable) with different numbers (CS0, CS1, etc.)
- Pull-up resistors connected to multiple signal lines that might serve as chip selects

The presence of multiple select lines suggests a more complex SPI implementation with several slave devices, potentially offering multiple attack vectors or data sources.

**Pin arrangements** in characteristic patterns can identify SPI interfaces even when explicit labeling is absent. Standard layouts include:

- Four pins in a row (MOSI, MISO, SCLK, CS)
- Six pins including power and ground (VCC, GND, MOSI, MISO, SCLK, CS)
- Eight pins for expanded SPI with additional control signals (e.g., write protect, hold)

These arrangements may appear as pin headers, test points, or unpopulated footprints on the PCB. The consistent grouping of 4+ pins in close proximity serves as a visual cue for potential SPI interfaces.

### Electrical Identification

When visual inspection doesn't yield conclusive results, electrical analysis can confirm the presence and characteristics of SPI interfaces.

**Logic analyzer patterns** provide definitive identification of SPI signals. By connecting a logic analyzer to suspected pins during device operation, you can observe the distinctive electrical characteristics of SPI communication:

- A regular clock signal on the SCLK line
- Data transitions on MOSI/MISO lines coordinated with clock edges
- Chip select transitions marking the beginning and end of transactions
- Burst patterns of activity with idle periods between

Many logic analyzers include SPI protocol decoders that can automatically identify and interpret these patterns, including determining the SPI mode based on the relationship between clock polarity and data transitions.

**Chip select behavior** follows predictable patterns that distinguish it from other signals:

- Active-low operation (transitions from high to low when active)
- Remains low for the duration of a complete transaction
- Returns high during idle periods
- Only activates one slave device at a time (typically)

By monitoring suspected CS lines, you can observe these activation patterns correlating with data transfers on the MOSI/MISO lines, confirming their function as chip selects.

**Signal timing analysis** reveals the relationship between clock edges and data transitions that characterize SPI communication:

- Data line (MOSI/MISO) transitions should occur in sync with one edge of the clock
- Stable data should be present during the sampling edge of the clock
- These timing relationships should match one of the four SPI modes

By examining the precise timing between clock and data signals, you can not only confirm SPI communication but also determine which SPI mode is in use, essential information for any further interaction with the interface.

<table>
  <tr>
    <th>Indicator</th>
    <th>Reliability</th>
    <th>Requirements</th>
    <th>Notes</th>
  </tr>
  <tr>
    <td>Labeled Pins</td>
    <td>High</td>
    <td>Good lighting, possibly magnification</td>
    <td>Most reliable but not always present</td>
  </tr>
  <tr>
    <td>Flash Packages</td>
    <td>Medium-High</td>
    <td>Knowledge of IC packaging and markings</td>
    <td>Very common in consumer electronics</td>
  </tr>
  <tr>
    <td>Pin Groupings</td>
    <td>Medium</td>
    <td>Understanding of PCB layout patterns</td>
    <td>May be confused with other serial protocols</td>
  </tr>
  <tr>
    <td>Logic Analysis</td>
    <td>Very High</td>
    <td>Logic analyzer, active device</td>
    <td>Definitive but requires equipment</td>
  </tr>
  <tr>
    <td>Signal Timing</td>
    <td>Very High</td>
    <td>Oscilloscope or logic analyzer</td>
    <td>Can determine SPI mode as well</td>
  </tr>
</table>

## Hardware for SPI Hacking

```
   ┌─────────────────────────────────────────────┐
   │           SPI HACKING TOOLKIT                │
   │                                             │
   │   ┌──────────────┐                      │
   │   │  LOGIC ANALYZER │          ANALYSIS     │
   │   └──────────────┘                      │
   │                                             │
   │   ┌──────────────┐                      │
   │   │    USB-TO-SPI  │          INTERACTION   │
   │   └──────────────┘                      │
   │                                             │
   │   ┌──────────────┐                      │
   │   │     CLIPS &    │          CONNECTION    │
   │   │     PROBES     │                      │
   │   └──────────────┘                      │
   │                                             │
   │   ┌──────────────┐                      │
   │   │    SOFTWARE    │          EXTRACTION    │
   │   │    UTILITIES   │                      │
   │   └──────────────┘                      │
   │                                             │
   └─────────────────────────────────────────────┘
```

Effective SPI hacking requires specialized hardware and software tools that enable observation, analysis, interaction, and data extraction. The higher speeds and direct-connect architecture of SPI create unique requirements compared to other protocols, demanding appropriate equipment for successful security research.

### Essential Hardware Tools

Hardware security analysis of SPI interfaces involves a toolkit designed for capturing, analyzing, and interacting with these high-speed signals.

**Logic analyzers** serve as the primary observation tool for SPI traffic. These devices capture digital signals at high sampling rates and decode them according to protocol rules. For effective SPI analysis, a logic analyzer should support:

- Sampling rates at least 5x the target SPI clock frequency (e.g., 50+ MHz for a 10 MHz SPI clock)
- At least 4 input channels to capture SCLK, MOSI, MISO, and CS simultaneously
- Protocol-specific decoding capabilities to interpret SPI frames automatically
- Sufficient buffer depth to capture extended transactions
- Triggering options to capture specific events or commands

Popular choices include Saleae Logic analyzers, inexpensive open-source devices compatible with Sigrok/PulseView, and higher-end test equipment from vendors like Tektronix or Keysight for professional applications. The logic analyzer provides the critical first view into SPI communications, revealing command structures, timing patterns, and data formats.

**SPI adapters/programmers** enable active interaction with SPI devices, allowing direct reading, writing, and control. These adapters serve as a bridge between your computer and the target SPI interface. Common options include:

- **Dedicated SPI programmers**: CH341A programmers, specialized flash readers
- **Multi-protocol tools**: Bus Pirate, Shikra, Multi-Protocol Analyzer
- **Development platforms**: Arduino, Raspberry Pi, ESP32 with appropriate software
- **Professional programmers**: Xeltek SuperPro, Data I/O programmers (for production use)

These devices typically connect to the host computer via USB and provide pin headers or cables for connecting to the target SPI interface. Many include support for multiple voltage levels (1.8V, 3.3V, 5V) to safely interface with different target systems.

**Connection hardware** proves critical for reliable physical access to SPI signals. The quality of the physical connection directly impacts signal integrity and measurement reliability, particularly at higher speeds. Essential connection options include:

- **SOIC/SOP test clips**: Spring-loaded clips that attach directly to surface-mount flash chips without requiring desoldering
- **WSON/DFN adapters**: Special adapters for connecting to no-lead packages
- **Micro grabbers and test hooks**: For attaching to test points or exposed pins
- **Breakout boards**: For connecting to various package types
- **Jumper wires**: For breadboard prototyping and connecting to pin headers

Having multiple connection options prepares you for different physical scenarios, from neatly arranged pin headers to densely packed surface-mount components with minimal access. For memory chips, test clips designed specifically for the package type (SOIC-8, WSON-8, etc.) provide the most reliable connection without requiring component removal.

**Specialized SPI tools** address specific use cases or target components:

- **External flash programmers**: Purpose-built for reading and writing SPI flash memory
- **EEPROM programmers**: For configuration memory access
- **In-circuit emulators**: For replacing and simulating SPI devices
- **High-speed oscilloscopes**: For analyzing signal integrity issues or timing problems

These specialized tools may be necessary for specific targets or when standard approaches prove insufficient. For professional hardware security research, having access to this broader range of equipment expands the types of targets and attacks that can be explored.

### Software Tools

Hardware tools require appropriate software to control them and analyze the captured data. A comprehensive SPI hacking toolkit includes several software categories.

**Flashrom** stands as the premier open-source utility for working with SPI flash memory chips. This versatile tool supports:

- A wide range of flash chips (over 500 models) from various manufacturers
- Multiple programmer hardware interfaces (CH341A, Bus Pirate, dedicated programmers)
- Reading, writing, and verifying flash contents
- Chip identification and information retrieval
- Selective operations on specific regions of flash memory

Available for Linux, Windows (via WSL or native ports), and macOS, Flashrom provides a consistent interface across platforms. For hardware hackers targeting firmware extraction, this tool often serves as the primary software interface for accessing SPI flash storage.

Basic Flashrom commands include:
```bash
# Identify the flash chip
flashrom -p ch341a_spi

# Read the entire chip contents to a file
flashrom -p ch341a_spi -r flash_dump.bin

# Write a modified firmware image
flashrom -p ch341a_spi -w modified_firmware.bin
```

**Vendor-specific SPI tools** supplement generic utilities with specialized features for particular chips or programmers:

- **Manufacturer programmers**: Dedicated software from Winbond, Macronix, etc.
- **CH341A Software**: Alternative interfaces for this common programmer
- **Custom GUI tools**: Often provide visual interfaces for memory operations

These tools sometimes offer functionality not available in generic software, such as accessing protected regions, specialized commands, or optimized interfaces for specific chip families.

**Protocol analyzer software** transforms captured SPI signals into human-readable information:

- **Saleae Logic software**: Clean interface with powerful protocol decoding
- **Sigrok/PulseView**: Open-source alternative with extensive protocol support
- **Proprietary analyzer software**: For commercial logic analyzers and oscilloscopes

These applications decode raw digital signals into meaningful SPI transactions, showing command bytes, addresses, data values, and timing relationships. Advanced features often include filtering, searching, and export capabilities that help identify patterns or extract specific data from complex captures.

**Custom scripts and development tools** extend capabilities beyond what standard tools provide:

- **Python libraries**: spidev, pyftdi, and other interfaces for custom SPI interaction
- **Arduino sketches**: For custom hardware-based attacks or specialized reading
- **Data analysis scripts**: For post-processing of extracted data
- **Firmware analysis tools**: Binwalk, hexdump, strings for examining extracted content

Developing custom tools becomes particularly valuable when standard approaches don't address unique requirements or when automating complex attack sequences. For hardware security researchers, the ability to create specialized tools significantly expands the range of possible techniques and targets.

<table>
  <tr>
    <th>Tool Type</th>
    <th>Example Products</th>
    <th>Approximate Cost</th>
    <th>Primary Function</th>
  </tr>
  <tr>
    <td>Logic Analyzer</td>
    <td>Saleae Logic 8, DSLogic Pro, Kingst LA</td>
    <td>$100-$500</td>
    <td>Capture and decode SPI traffic</td>
  </tr>
  <tr>
    <td>SPI Programmer</td>
    <td>CH341A Mini, Bus Pirate, Dediprog SF100</td>
    <td>$10-$300</td>
    <td>Read/write SPI flash memory</td>
  </tr>
  <tr>
    <td>Test Clips</td>
    <td>Pomona SOIC-8 clip, Tag-Connect cables</td>
    <td>$15-$60</td>
    <td>Connect to SMD components</td>
  </tr>
  <tr>
    <td>Software</td>
    <td>Flashrom, PulseView, custom scripts</td>
    <td>Free-$50</td>
    <td>Control hardware, analyze data</td>
  </tr>
  <tr>
    <td>Complete Kit</td>
    <td>Basic: CH341A+clips+Flashrom</td>
    <td>~$30</td>
    <td>Minimal flash reading setup</td>
  </tr>
  <tr>
    <td>Professional Setup</td>
    <td>Logic analyzer+programmers+adapters</td>
    <td>$500-$2000</td>
    <td>Comprehensive SPI research platform</td>
  </tr>
</table>

A basic SPI hacking toolkit can be assembled for under $100, with a CH341A programmer (~$10), a SOIC clip (~$15), and open-source software. This entry-level setup enables flash reading from many common devices. For professional hardware security research, a more comprehensive kit includes higher-quality tools, multiple connection options, and advanced analysis capabilities.

## SPI Hacking Techniques

### Flash Memory Extraction

1. **In-circuit reading**: Connecting to flash while in the target system
2. **Chip removal**: Desoldering the flash chip for direct access
3. **Command sequences**: Using standard flash commands (e.g., 0x9F for JEDEC ID)
4. **Content analysis**: Examining extracted firmware for vulnerabilities

### Passive Sniffing

1. **Logic analyzer connection**: Attach to all SPI lines
2. **Boot sequence capture**: Record initialization and configuration
3. **Protocol analysis**: Decode commands and data
4. **Signal integrity**: Ensure proper connections for reliable capture

### Active Attacks

1. **Man-in-the-Middle**: Intercepting and modifying communications
2. **Bus mastering**: Taking control of the SPI bus
3. **Flash modification**: Altering firmware or configuration data
4. **Chip emulation**: Spoofing responses from SPI devices

## Common SPI Security Issues

1. **Unencrypted storage**: Firmware and sensitive data in cleartext
2. **Lack of write protection**: Unprotected flash memory
3. **Accessible test points**: Exposed SPI lines on PCB
4. **No authentication**: Any device with access can read/write
5. **Debug interfaces**: SPI programming headers left enabled
6. **Boot vulnerabilities**: Insecure verification of boot code

## Practical SPI Hacking: Flash Memory Extraction

### Extracting Firmware from SPI Flash

**Equipment needed:**
- SPI flash reader (e.g., CH341A programmer, Bus Pirate)
- SOIC clip or probe wires
- Computer with appropriate software (flashrom)
- Target device with SPI flash

**Procedure:**
1. Identify the SPI flash chip on the target board
2. Determine the chip model and pinout
3. Connect reader to appropriate pins (CS, MISO, MOSI, SCLK, GND, VCC)
4. Use flashrom to identify the chip: `flashrom -p <programmer> --chip-identify`
5. Read the chip contents: `flashrom -p <programmer> -r flash_dump.bin`
6. Verify the read with a second extraction and compare checksums
7. Analyze the extracted firmware for vulnerabilities or sensitive data

### Example: Reading a Flash Chip with Flashrom and CH341A

```bash
# Identify the flash chip
flashrom -p ch341a_spi

# Read the chip contents
flashrom -p ch341a_spi -r flash_dump.bin

# Verify with second read
flashrom -p ch341a_spi -r flash_verify.bin

# Compare checksums
md5sum flash_dump.bin flash_verify.bin
```

## Advanced SPI Techniques

### SPI Flash IC Direct Manipulation

1. **Status register modification**: Changing protection states
2. **Partial reprogramming**: Modifying specific sections
3. **Bit flipping attacks**: Targeted modification of security bits
4. **Block protection bypass**: Circumventing software write protection

### Hardware-Based Attacks

1. **Glitching**: Manipulating power or clock during operations
2. **Fault injection**: Introducing errors to bypass security
3. **Cold boot attacks**: Preserving memory contents for extraction
4. **Decapsulation**: Removing chip packaging for direct probe access

## Securing SPI Communications

As a hardware hacker, understanding proper security measures helps identify weaknesses:

1. **Hardware write protection**: Using WP pin or internal lock bits
2. **Authenticated reads/writes**: Implementing challenge-response
3. **Encrypted storage**: Encrypting sensitive data in flash
4. **Secure boot**: Cryptographic verification of firmware
5. **Physical protection**: Limiting access to SPI lines
6. **Memory scrambling**: Obfuscating stored data

## Conclusion

SPI interfaces are critical targets for hardware hackers due to their connection to firmware storage and configuration data. The protocol's simplicity and lack of built-in security make it particularly vulnerable to various attacks.

By understanding SPI communications, hardware hackers can extract firmware, modify device behavior, and potentially uncover security vulnerabilities that would be inaccessible through software alone.

In the next section, we'll explore [JTAG and SWD Protocols](./05d-jtag-swd.md), which provide even deeper access into embedded systems.
