# SPI (Serial Peripheral Interface) Protocol

```
   ┌─────────────────────────────────────────────┐
   │          SPI COMMUNICATION MODEL             │
   │                                             │
   │    ┌─────────────┐                         │
   │    │    MASTER    │                         │
   │    └─┬─┬─┬─┬─┘                         │
   │      │ │ │ │                           │
   │  SCLK │ │ │ │                           │
   │  ────── │ │ │                           │
   │  MOSI │ │ │ │                           │
   │  ─────── │ │                           │
   │  MISO │ │ │ │                           │
   │  ──────── │                           │
   │  CS1  │ │ │                            │
   │  ─────────                            │
   │  CS2  │ │                             │
   │  ──────────                            │
   │  CS3  │                              │
   │  ──────────                            │
   │      │ │ │ │                           │
   │      ↓ ↓ ↓ ↓                           │
   │    ┌──┬─┘ ┌──┬─┘ ┌──┬─┘             │
   │    │SLAVE│ │SLAVE│ │SLAVE│             │
   │    │  1  │ │  2  │ │  3  │             │
   │    └────┘ └────┘ └────┘             │
   │                                             │
   └─────────────────────────────────────────────┘
```

In the ecosystem of embedded communications, the Serial Peripheral Interface (SPI) stands as a high-performance contender, offering remarkable simplicity paired with impressive speed capabilities. Developed by Motorola in the mid-1980s, SPI has evolved into one of the most widely adopted protocols for short-distance communication in embedded systems, particularly where speed-critical applications demand efficient data transfer.

Unlike the address-based sharing approach of I²C, SPI takes a direct, dedicated connection approach. It creates point-to-point links between a controlling master device and its selected peripheral slaves, establishing a straightforward communication channel that sacrifices pin efficiency for performance and simplicity. This architecture makes SPI particularly valuable for applications requiring high-throughput data transfer, such as interfacing with sensors that produce large data volumes, connecting to high-resolution displays, or accessing flash memory where read and write speed directly impacts system performance.

For hardware hackers, SPI interfaces represent prime targets for exploration. They frequently connect to some of the most valuable components in modern electronics—firmware storage chips, encryption modules, and configuration memories. The protocol's widespread adoption, combined with its lack of built-in security features, creates numerous opportunities for security research and device analysis. Understanding SPI fundamentals provides a foundation for advanced hardware hacking techniques, from passive analysis to active manipulation of target systems.

## SPI Fundamentals

### Basics of SPI

The Serial Peripheral Interface distinguishes itself from other communication protocols through several defining characteristics that shape both its applications and security profile.

**Synchronous communication** forms the foundation of SPI operation. Unlike asynchronous protocols like UART that require precise timing agreement, SPI uses an explicit clock signal (SCLK) generated by the master to coordinate all data transfers. This clock synchronization offers several advantages:
- Eliminates the need for timing calibration between devices
- Allows for flexible communication speeds that can be adjusted on-the-fly
- Supports higher data rates than many asynchronous protocols
- Provides greater tolerance for timing variations between components

At each clock pulse, data bits transfer between master and slave, creating a structured and reliable communication system with little overhead.

**Full-duplex capability** sets SPI apart from many other serial protocols by enabling simultaneous bidirectional data transfer. With separate data lines for transmission (MOSI - Master Out Slave In) and reception (MISO - Master In Slave Out), the master and selected slave can send data to each other at the same time. This simultaneous communication doubles the effective throughput compared to half-duplex protocols, making SPI particularly efficient for applications requiring continuous data exchange, such as streaming sensor readings while sending configuration commands.

**The four-wire interface** represents the standard SPI implementation, though variations exist:

1. SCLK (Serial Clock) - The master-generated timing reference
2. MOSI (Master Out Slave In) - Data from master to slave 
3. MISO (Master In Slave Out) - Data from slave to master
4. CS/SS (Chip Select/Slave Select) - Selection signal for specific slave devices

Additional signal lines may appear in some implementations, such as write protection (WP) or hold (HOLD), particularly with memory devices. These supplementary lines provide additional control options but aren't part of the core SPI specification.

**The master-slave architecture** establishes a clear hierarchy in SPI systems. The master device (typically a microcontroller or processor) controls all aspects of communication:
- Generating the clock signal that times all transfers
- Selecting which slave device to communicate with
- Initiating all data transfers
- Determining the communication speed

Slave devices remain passive participants, responding only when selected by the master via their respective CS lines. This centralized control simplifies the protocol by eliminating the need for bus arbitration or collision detection mechanisms found in multi-master protocols, but it also concentrates security control at the master device.

```
   ┌─────────────────────────────────────────────┐
   │           SPI SIGNAL TRANSFER                │
   │                                             │
   │  CS   ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄    │
   │       ██                              ██    │
   │  SCLK ██████_██████_██████_██████_██████    │
   │                                             │
   │  MOSI ████████__██__████████__██__██████    │
   │            bit7  bit6  bit5  bit4  bit3      │
   │                                             │
   │  MISO ██__████████__██__████████__██__    │
   │            bit7  bit6  bit5  bit4  bit3      │
   │                                             │
   └─────────────────────────────────────────────┘
```

**The absence of an addressing scheme** differentiates SPI from protocols like I²C. Rather than sending address information over the data lines, SPI uses dedicated Chip Select (CS) lines for each slave device. When the master wishes to communicate with a specific slave, it activates only that slave's CS line (typically by driving it low) while keeping all other CS lines inactive. This direct selection approach:
- Eliminates addressing overhead in the data stream
- Allows for simpler slave implementation
- Supports any number of identical devices without address conflicts
- Creates a potential scaling issue as each slave requires a dedicated CS line

The direct selection method makes SPI particularly efficient for small numbers of peripherals but less practical for systems with many devices due to the increasing pin count requirements.

**Superior speed capabilities** make SPI the protocol of choice for performance-critical applications. Without the overhead of addressing or acknowledgment bits, and with clock rates frequently running from 10 MHz to 100+ MHz, SPI can achieve data transfer rates orders of magnitude faster than I²C or UART. This high-speed capability makes SPI ideal for:
- Flash memory access where read/write speed is critical
- Display interfaces requiring high refresh rates
- Data acquisition from high-resolution sensors
- Real-time control applications with strict timing requirements

For hardware hackers, this speed characteristic is significant since it may require more sophisticated equipment to properly analyze SPI signals at their maximum rates.

### Signal Lines

The four signal lines that comprise standard SPI each serve specific functions in creating a robust communication channel. Understanding their roles and characteristics is essential for both analyzing and manipulating SPI interfaces.

**SCLK (Serial Clock)** provides the timing foundation for all SPI communications. Generated exclusively by the master device, this signal coordinates when data bits are placed on the data lines and when they should be sampled by the receiving device. Key characteristics include:

- **Programmable frequency**: The master can adjust clock speed to accommodate different slave capabilities
- **Idle state**: Can be configured to rest at either high or low (determined by CPOL parameter)
- **Active edges**: Either rising or falling edges can trigger data sampling (determined by CPHA parameter)
- **Continuous operation**: During a transfer, the clock runs continuously until all data is exchanged

From a security perspective, the clock line can be monitored to determine when sensitive data might be transferred, potentially enabling timing-based attacks.

**MOSI (Master Out Slave In)** carries data from the master to the selected slave(s). This unidirectional line has several important characteristics:

- **Bit ordering**: Data is typically transmitted most significant bit (MSB) first, though some implementations use least significant bit (LSB) first
- **Data placement**: The master places new bits on this line in coordination with the clock signal
- **Shared connection**: All slaves receive the same MOSI signal, but only the selected device (with active CS) processes it
- **Idle state**: When not transmitting, this line may float or be driven to a specific level depending on implementation

From a hardware hacking perspective, the MOSI line carries command sequences, addresses, and write data—all potentially valuable information for understanding device operation or identifying security weaknesses.

**MISO (Master In Slave Out)** serves as the return path, carrying data from the selected slave back to the master. Its characteristics mirror MOSI but in the opposite direction:

- **Single active driver**: Only the currently selected slave should drive this line
- **High-impedance state**: Unselected slaves must tri-state their MISO connections to avoid conflicts
- **Data timing**: The slave places data on this line synchronized with the clock signal
- **Shared connection**: Despite coming from different slaves, all MISO outputs connect to a single master input

For hardware security analysis, the MISO line carries response data that may include sensitive information like configuration data, memory contents, or status information revealing the internal state of the target device.

**CS/SS (Chip Select/Slave Select)** implements the direct addressing mechanism of SPI. These dedicated selection lines have several distinctive properties:

- **Active-low operation**: Typically, a low voltage (0) selects a slave while high (1) deselects it
- **One per slave**: Each slave device requires its own dedicated CS line from the master
- **Multiple selects**: Some implementations allow selecting multiple slaves simultaneously for broadcast operations
- **Framing function**: The CS transition from inactive to active signals the start of a transaction, while the return to inactive marks its completion

The CS lines effectively serve as an "enable" signal, determining which slave device is currently allowed to participate in communication. This direct selection method is both a strength (no addressing overhead) and a limitation (requires more pins) of the SPI protocol.

### SPI Modes

<table>
  <tr>
    <th>Mode</th>
    <th>CPOL<br>(Clock Polarity)</th>
    <th>CPHA<br>(Clock Phase)</th>
    <th>Clock Idle State</th>
    <th>Data Sampled On</th>
    <th>Common Devices</th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>Low</td>
    <td>Rising Edge</td>
    <td>Most Microcontrollers, Many Flash Memory Chips</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>Low</td>
    <td>Falling Edge</td>
    <td>TI Digital Signal Processors, Some Sensors</td>
  </tr>
  <tr>
    <td>2</td>
    <td>1</td>
    <td>0</td>
    <td>High</td>
    <td>Falling Edge</td>
    <td>Motorola Processors (Older), Some Display Controllers</td>
  </tr>
  <tr>
    <td>3</td>
    <td>1</td>
    <td>1</td>
    <td>High</td>
    <td>Rising Edge</td>
    <td>AD Converters, Some Memory Devices</td>
  </tr>
</table>

One of SPI's distinctive characteristics is its configurability through four different operating modes, determined by two key parameters: clock polarity (CPOL) and clock phase (CPHA). This flexibility allows SPI to adapt to various slave device requirements but also introduces a layer of complexity for both developers and hardware hackers. Understanding these modes is crucial for successful communication and analysis.

**Clock Polarity (CPOL)** determines the idle state of the clock line (SCLK) when no data is being transferred:
- When CPOL=0, the clock idles at a low voltage level (0)
- When CPOL=1, the clock idles at a high voltage level (1)

This parameter effectively defines the "resting state" of the clock signal and forms the baseline from which active clock cycles are measured. The choice of polarity often depends on the slave device specifications or system-wide power considerations.

**Clock Phase (CPHA)** determines the timing relationship between clock edges and data sampling:
- When CPHA=0, data is sampled on the "first" clock edge (transition from idle)
- When CPHA=1, data is sampled on the "second" clock edge (transition back toward idle)

This parameter defines when the receiving device should consider the data on the line to be valid and stable. The selection of clock phase impacts the timing margins available for data setup and can affect reliability in high-speed applications.

**The resulting four modes** create distinct timing patterns that must be correctly matched between master and slave devices:

- **Mode 0 (CPOL=0, CPHA=0)**: Clock idles low, data is sampled on the rising edge (clock transition from low to high), and data changes on the falling edge. This is the most commonly used mode and often serves as the default for many SPI implementations.

- **Mode 1 (CPOL=0, CPHA=1)**: Clock idles low, data is sampled on the falling edge (clock transition from high to low), and data changes on the rising edge. This mode provides additional setup time for data bits when operating at higher frequencies.

- **Mode 2 (CPOL=1, CPHA=0)**: Clock idles high, data is sampled on the falling edge (clock transition from high to low), and data changes on the rising edge. This mode is less common but required by some specialized peripherals.

- **Mode 3 (CPOL=1, CPHA=1)**: Clock idles high, data is sampled on the rising edge (clock transition from low to high), and data changes on the falling edge. This mode is particularly common in certain analog-to-digital converters and some memory devices.

For hardware hackers, correctly identifying the SPI mode is essential for meaningful analysis. When monitoring SPI communications with a logic analyzer, selecting the wrong mode interpretation can result in completely misinterpreted data. Many SPI analysis tools provide automated mode detection by examining the relationship between CS activation, clock behavior, and data transitions.

During security assessments, it's sometimes necessary to attempt communication using different modes sequentially until correct operation is achieved. This trial-and-error approach is particularly relevant when working with undocumented devices or when manufacturer specifications are unavailable.

## Identifying SPI Interfaces

### Visual Identification

1. **Look for labeled pins**: MOSI/MISO/SCLK/CS, SPI, or abbreviations
2. **Flash memory chips**: Often connected via SPI (Winbond, Macronix, etc.)
3. **Multiple CS lines**: One per slave device
4. **Pin arrangements**: Often grouped together in 4 or more pins

### Electrical Identification

1. **Logic analyzer pattern**: Look for consistent clock signal with data lines
2. **Chip select behavior**: Active-low signals that enable specific devices
3. **Signal timing**: Data transitions relative to clock edges

## Hardware for SPI Hacking

### Essential Tools

1. **Logic analyzer**: To capture and decode SPI signals
2. **SPI adapter**: USB-to-SPI, Bus Pirate, or microcontroller-based solution
3. **Flashrom**: Software for reading/writing SPI flash chips
4. **Clips/probes**: For attaching to SPI flash chips in-circuit
5. **SOIC/WSON test clips**: For connecting to surface-mount flash chips

### Software Tools

1. **Flashrom**: Open-source utility for reading/writing SPI flash
2. **SPI Flash tools**: Vendor-specific programming tools
3. **Protocol analyzers**: Saleae Logic, Sigrok/PulseView
4. **Custom scripts**: Python/Arduino for SPI communication

## SPI Hacking Techniques

### Flash Memory Extraction

1. **In-circuit reading**: Connecting to flash while in the target system
2. **Chip removal**: Desoldering the flash chip for direct access
3. **Command sequences**: Using standard flash commands (e.g., 0x9F for JEDEC ID)
4. **Content analysis**: Examining extracted firmware for vulnerabilities

### Passive Sniffing

1. **Logic analyzer connection**: Attach to all SPI lines
2. **Boot sequence capture**: Record initialization and configuration
3. **Protocol analysis**: Decode commands and data
4. **Signal integrity**: Ensure proper connections for reliable capture

### Active Attacks

1. **Man-in-the-Middle**: Intercepting and modifying communications
2. **Bus mastering**: Taking control of the SPI bus
3. **Flash modification**: Altering firmware or configuration data
4. **Chip emulation**: Spoofing responses from SPI devices

## Common SPI Security Issues

1. **Unencrypted storage**: Firmware and sensitive data in cleartext
2. **Lack of write protection**: Unprotected flash memory
3. **Accessible test points**: Exposed SPI lines on PCB
4. **No authentication**: Any device with access can read/write
5. **Debug interfaces**: SPI programming headers left enabled
6. **Boot vulnerabilities**: Insecure verification of boot code

## Practical SPI Hacking: Flash Memory Extraction

### Extracting Firmware from SPI Flash

**Equipment needed:**
- SPI flash reader (e.g., CH341A programmer, Bus Pirate)
- SOIC clip or probe wires
- Computer with appropriate software (flashrom)
- Target device with SPI flash

**Procedure:**
1. Identify the SPI flash chip on the target board
2. Determine the chip model and pinout
3. Connect reader to appropriate pins (CS, MISO, MOSI, SCLK, GND, VCC)
4. Use flashrom to identify the chip: `flashrom -p <programmer> --chip-identify`
5. Read the chip contents: `flashrom -p <programmer> -r flash_dump.bin`
6. Verify the read with a second extraction and compare checksums
7. Analyze the extracted firmware for vulnerabilities or sensitive data

### Example: Reading a Flash Chip with Flashrom and CH341A

```bash
# Identify the flash chip
flashrom -p ch341a_spi

# Read the chip contents
flashrom -p ch341a_spi -r flash_dump.bin

# Verify with second read
flashrom -p ch341a_spi -r flash_verify.bin

# Compare checksums
md5sum flash_dump.bin flash_verify.bin
```

## Advanced SPI Techniques

### SPI Flash IC Direct Manipulation

1. **Status register modification**: Changing protection states
2. **Partial reprogramming**: Modifying specific sections
3. **Bit flipping attacks**: Targeted modification of security bits
4. **Block protection bypass**: Circumventing software write protection

### Hardware-Based Attacks

1. **Glitching**: Manipulating power or clock during operations
2. **Fault injection**: Introducing errors to bypass security
3. **Cold boot attacks**: Preserving memory contents for extraction
4. **Decapsulation**: Removing chip packaging for direct probe access

## Securing SPI Communications

As a hardware hacker, understanding proper security measures helps identify weaknesses:

1. **Hardware write protection**: Using WP pin or internal lock bits
2. **Authenticated reads/writes**: Implementing challenge-response
3. **Encrypted storage**: Encrypting sensitive data in flash
4. **Secure boot**: Cryptographic verification of firmware
5. **Physical protection**: Limiting access to SPI lines
6. **Memory scrambling**: Obfuscating stored data

## Conclusion

SPI interfaces are critical targets for hardware hackers due to their connection to firmware storage and configuration data. The protocol's simplicity and lack of built-in security make it particularly vulnerable to various attacks.

By understanding SPI communications, hardware hackers can extract firmware, modify device behavior, and potentially uncover security vulnerabilities that would be inaccessible through software alone.

In the next section, we'll explore [JTAG and SWD Protocols](./05d-jtag-swd.md), which provide even deeper access into embedded systems.
